VectorEx: @value @print type = {
  public x: float = (); // TODO: try taking these private once this replaces the cpp1 Vector class
  public y: float = ();
  public z: float = ();
  operator=: (out this, px: float, py: float, pz: float) = {
    x = px;
	y = py;
	z = pz;
  }
  From: (this, px: double, py: double, pz: double) -> VectorEx = {
	return VectorEx(px, py, pz);
  }
  Cross: (this, v: VectorEx) -> VectorEx = {
     return VectorEx(
		this.x * v.y - this.y * v.x,
		this.y * v.z - this.z * v.y,
		this.z * v.x - this.x * v.z
	 );
  }

  Plus: (this, b: VectorEx) -> VectorEx = {
    return VectorEx(this.x + b.x, this.y + b.y, this.z + b.z);
  }

  Minus: (this, v: VectorEx) -> VectorEx = {
     return VectorEx(
		this.x - v.x,
		this.y - v.y,
		this.z - v.z
	 );
  }

  Negated: (this) -> VectorEx = {
    return VectorEx(-this.x, -this.y, -this.z);
  }

  Dot: (this, b: VectorEx) -> float = {
      return (this.x * b.x + this.y * b.y + this.z * b.z);
  }
  ToString: (this) -> std::string = {
	return "eeep3 x: (this.x)$ y: (this.y)$ z: (this.z)$";
  }
  DistanceToLine: (a: VectorEx, b: VectorEx) -> double = {
	return 1.0; // TODO: actually calculate distance
  }
  WithMagnitude: (this, v: double) -> VectorEx = {
    m: double = this.Magnitude();
    if (EXACT(m == 0)) { // we can do a zero vector with zero magnitude, but not any other cases
	  if (fabs(v) > 1e-100) {
        // dbp("VectorEx::WithMagnitude(%g) of zero vector!", v);
      }
	  return this.From(0, 0, 0);
    } else {
	  return this.ScaledBy(v / m);
    }
  }
  MagSquared: (this) -> double = { // TODO: implement
    return 1.0; // return (this.x * this.px + this.y * this.py + this.z * this.z);
  }
  Magnitude: (this) -> double = { // TODO: implement
    return 1.0; // sqrt(this.px * this.px + this.py * this.py + this.pz * this.pz);
  }
  ScaledBy: (this, v: double) -> VectorEx = {
    return VectorEx(this.x * v, this.y * v, this.z * v);
  }
  ScaleOutOfCsys: (this, u: VectorEx, v: VectorEx, n: VectorEx) -> VectorEx = {
    r: VectorEx = u.ScaledBy(this.x).Plus(
	  v.ScaledBy(this.y).Plus(
	  n.ScaledBy(this.z)));
    return r;
  }

  OnLineSegment: (this, a: VectorEx, b: VectorEx, tol: double = LENGTH_EPS) -> bool = {
    if (this.Equals(a, tol) || this.Equals(b, tol)) { return true; }

    d: VectorEx = b.Minus(a);
    m: double = d.MagSquared();
    distsq: double = ((this.Minus(a)).Cross(d)).MagSquared() / m;

    if (distsq >= tol * tol) { return false; }

    t: double = (this.Minus(a)).DivProjected(d);

    if (t < 0 || t > 1) { return false; } // on-endpoint already tested

    return true;
  }
  Equals: (this, v: VectorEx, tol: double = LENGTH_EPS) -> bool = {
    // quick axis-aligned tests before going further
	dv: VectorEx = this.Minus(v);
    if (fabs(dv.x) > tol) { return false; }
    if (fabs(dv.y) > tol) { return false; }
    if (fabs(dv.z) > tol) { return false; }

    return dv.MagSquared() < tol * tol;
  }
  DivProjected: (this, delta: VectorEx) -> double = {
    return (this.x * delta.x + this.y * delta.y + this.z * delta.z)
         / (delta.x * delta.x + delta.y * delta.y + delta.z * delta.z);
  }
}

STriangleEx: type = {
  tag: i32 = ();
  meta: STriMeta = ();

  public a: VectorEx = (); // TODO: try taking these private once this replaces the cpp1 Vector class
  public b: VectorEx = ();
  public c: VectorEx = ();

  public an: VectorEx = ();
  public bn: VectorEx = ();
  public cn: VectorEx = ();

  operator=: (out this) = {
    meta = STriMeta();
  }

  operator=: (out this, metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;
  }

  operator=: (out this, metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx, anx: VectorEx, bnx: VectorEx, cnx: VectorEx) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;

    an = anx;
	bn = bnx;
	cn = cnx;
  }

  From: (metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx) -> STriangleEx = {
    return STriangleEx(metax, ax, bx, cx);
  }
  
  Normal: (this) -> VectorEx = {
    ab: VectorEx = this.b.Minus(this.a);
	bc: VectorEx = this.c.Minus(this.b);
    return ab.Cross(bc);
  }

  MinAltitude: (this) -> double = {
	altA: double = this.a.DistanceToLine(this.b, this.c.Minus(this.b));
	altB: double = this.b.DistanceToLine(this.c, this.a.Minus(this.c));
	altC: double = this.c.DistanceToLine(this.a, this.b.Minus(this.a));

    return min(altA, min(altB, altC));
  }

  ContainsPoint: (this, p: VectorEx) -> bool = {
    n: VectorEx = this.Normal();
    if (this.MinAltitude() < LENGTH_EPS) { // shouldn't happen; zero-area triangle
        return false;
    }
    return this.ContainsPointProjd(n.WithMagnitude(1.0), p);
  }

  ContainsPointProjd: (this, n: VectorEx, p: VectorEx) -> bool = {
    ab: VectorEx = this.b.Minus(this.a);
	bc: VectorEx = this.c.Minus(this.b);
	ca: VectorEx = this.a.Minus(this.c);

    no_ab: VectorEx = n.Cross(ab);
    if (no_ab.Dot(p) < no_ab.Dot(this.a) - LENGTH_EPS) { return false; }

    no_bc: VectorEx = n.Cross(bc);
    if (no_bc.Dot(p) < no_bc.Dot(this.b) - LENGTH_EPS) { return false; }

    no_ca: VectorEx = n.Cross(ca);
    if (no_ca.Dot(p) < no_ca.Dot(this.c) - LENGTH_EPS) { return false; }

    return true;
  }
  SignedVolume: (this) -> double = {
    return this.a.Dot(this.b.Cross(this.c)) / 6.0;
  }
  Area: (this) -> double = {
    ab: VectorEx = this.a.Minus(this.b);
    cb: VectorEx = this.c.Minus(this.b);
    return ab.Cross(cb).Magnitude() / 2.0;
  }

  IsDegenerate: (this) -> bool = {
    return this.a.OnLineSegment(this.b, this.c) ||
           this.b.OnLineSegment(this.a, this.c) ||
           this.c.OnLineSegment(this.a, this.b);
  }
  FlipNormal: (inout this) = {
    std::swap(this.a, this.b);
    std::swap(this.an, this.bn);
  }

  Transform: (this, u: VectorEx, v: VectorEx, n: VectorEx) -> STriangleEx = {
	return STriangleEx(this.meta,
	  this.a.ScaleOutOfCsys(u, v, n),
	  this.b.ScaleOutOfCsys(u, v, n),
	  this.c.ScaleOutOfCsys(u, v, n),
      this.an.ScaleOutOfCsys(u, v, n),
      this.bn.ScaleOutOfCsys(u, v, n),
      this.cn.ScaleOutOfCsys(u, v, n)
	);
  }
}
