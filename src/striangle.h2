STriangleEx: type = {
  tag: i32 = ();
  meta: STriMeta = ();

  public a: Vector = (); // TODO: try taking these private once this replaces the cpp1 Vector class
  public b: Vector = ();
  public c: Vector = ();

  public an: Vector = ();
  public bn: Vector = ();
  public cn: Vector = ();

  operator=: (out this) = {
    meta = STriMeta();
  }

  operator=: (out this, metax: STriMeta, ax: Vector, bx: Vector, cx: Vector) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;
  }

  operator=: (out this, metax: STriMeta, ax: Vector, bx: Vector, cx: Vector, anx: Vector, bnx: Vector, cnx: Vector) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;

    an = anx;
	bn = bnx;
	cn = cnx;
  }

  From: (metax: STriMeta, ax: Vector, bx: Vector, cx: Vector) -> STriangleEx = {
    return STriangleEx(metax, ax, bx, cx);
  }
  
  Normal: (this) -> Vector = {
    ab: Vector = this.b.Minus(this.a);
	bc: Vector = this.c.Minus(this.b);
    return ab.Cross(bc);
  }

  MinAltitude: (this) -> double = {
	altA: double = this.a.DistanceToLine(this.b, this.c.Minus(this.b));
	altB: double = this.b.DistanceToLine(this.c, this.a.Minus(this.c));
	altC: double = this.c.DistanceToLine(this.a, this.b.Minus(this.a));

    return min(altA, min(altB, altC));
  }

  ContainsPoint: (this, p: Vector) -> bool = {
    n: Vector = this.Normal();
    if (this.MinAltitude() < LENGTH_EPS) { // shouldn't happen; zero-area triangle
        return false;
    }
    return this.ContainsPointProjd(n.WithMagnitude(1.0), p);
  }

  ContainsPointProjd: (this, n: Vector, p: Vector) -> bool = {
    ab: Vector = this.b.Minus(this.a);
	bc: Vector = this.c.Minus(this.b);
	ca: Vector = this.a.Minus(this.c);

    no_ab: Vector = n.Cross(ab);
    if (no_ab.Dot(p) < no_ab.Dot(this.a) - LENGTH_EPS) { return false; }

    no_bc: Vector = n.Cross(bc);
    if (no_bc.Dot(p) < no_bc.Dot(this.b) - LENGTH_EPS) { return false; }

    no_ca: Vector = n.Cross(ca);
    if (no_ca.Dot(p) < no_ca.Dot(this.c) - LENGTH_EPS) { return false; }

    return true;
  }
  SignedVolume: (this) -> double = {
    return this.a.Dot(this.b.Cross(this.c)) / 6.0;
  }
  Area: (this) -> double = {
    ab: Vector = this.a.Minus(this.b);
    cb: Vector = this.c.Minus(this.b);
    return ab.Cross(cb).Magnitude() / 2.0;
  }

  IsDegenerate: (this) -> bool = {
    return this.a.OnLineSegment(this.b, this.c) ||
           this.b.OnLineSegment(this.a, this.c) ||
           this.c.OnLineSegment(this.a, this.b);
  }
  FlipNormal: (inout this) = {
    std::swap(this.a, this.b);
    std::swap(this.an, this.bn);
  }

  Transform: (this, u: Vector, v: Vector, n: Vector) -> STriangleEx = {
	return STriangleEx(this.meta,
	  this.a.ScaleOutOfCsys(u, v, n),
	  this.b.ScaleOutOfCsys(u, v, n),
	  this.c.ScaleOutOfCsys(u, v, n),
      this.an.ScaleOutOfCsys(u, v, n),
      this.bn.ScaleOutOfCsys(u, v, n),
      this.cn.ScaleOutOfCsys(u, v, n)
	);
  }
}
