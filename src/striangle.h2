VectorEx: @value @print type = {
  px: float = ();
  py: float = ();
  pz: float = ();
  operator=: (out this, x: float, y: float, z: float) = {
    px = x;
	py = y;
	pz = z;
  }
  From: (this, x: double, y: double, z: double) -> VectorEx = {
	return VectorEx(x, y, z);
  }
  Cross: (this, v: VectorEx) -> VectorEx = {
     return VectorEx(
		this.px * v.py - this.py * v.px,
		this.py * v.pz - this.pz * v.py,
		this.pz * v.px - this.px * v.pz
	 );
  }

  Plus: (this, b: VectorEx) -> VectorEx = {
    return VectorEx(this.px + b.px, this.py + b.py, this.pz + b.pz);
  }

  Minus: (this, v: VectorEx) -> VectorEx = {
     return VectorEx(
		this.px - v.px,
		this.py - v.py,
		this.pz - v.pz
	 );
  }

  Negated: (this) -> VectorEx = {
    return VectorEx(-this.px, -this.py, -this.pz);
  }

  Dot: (this, b: VectorEx) -> float = {
      return (this.px * b.px + this.py * b.py + this.pz * b.pz);
  }
  ToString: (this) -> std::string = {
	return "eeep3 x: (this.px)$ y: (this.py)$ z: (this.pz)$";
  }
  DistanceToLine: (a: VectorEx, b: VectorEx) -> double = {
	return 1.0; // TODO: actually calculate distance
  }
  WithMagnitude: (this, v: double) -> VectorEx = {
    m: double = this.Magnitude();
    if (EXACT(m == 0)) { // we can do a zero vector with zero magnitude, but not any other cases
	  if (fabs(v) > 1e-100) {
        // dbp("VectorEx::WithMagnitude(%g) of zero vector!", v);
      }
	  return this.From(0, 0, 0);
    } else {
	  return this.ScaledBy(v / m);
    }
  }
  MagSquared: (this) -> double = { // TODO: implement
    return 1.0; // return (this.px * this.px + this.py * this.py + this.pz * this.pz);
  }
  Magnitude: (this) -> double = { // TODO: implement
    return 1.0; // sqrt(this.px * this.px + this.py * this.py + this.pz * this.pz);
  }
  ScaledBy: (this, v: double) -> VectorEx = {
    return VectorEx(this.px * v, this.py * v, this.pz * v);
  }
  ScaleOutOfCsys: (this, u: VectorEx, v: VectorEx, n: VectorEx) -> VectorEx = {
    r: VectorEx = u.ScaledBy(this.px).Plus(
	  v.ScaledBy(this.py).Plus(
	  n.ScaledBy(this.pz)));
    return r;
  }

  OnLineSegment: (this, a: VectorEx, b: VectorEx, tol: double = LENGTH_EPS) -> bool = {
    if (this.Equals(a, tol) || this.Equals(b, tol)) { return true; }

    d: VectorEx = b.Minus(a);
    m: double = d.MagSquared();
    distsq: double = ((this.Minus(a)).Cross(d)).MagSquared() / m;

    if (distsq >= tol * tol) { return false; }

    t: double = (this.Minus(a)).DivProjected(d);

    if (t < 0 || t > 1) { return false; } // on-endpoint already tested

    return true;
  }
  Equals: (this, v: VectorEx, tol: double = LENGTH_EPS) -> bool = {
    // quick axis-aligned tests before going further
	dv: VectorEx = this.Minus(v);
    if (fabs(dv.px) > tol) { return false; }
    if (fabs(dv.py) > tol) { return false; }
    if (fabs(dv.pz) > tol) { return false; }

    return dv.MagSquared() < tol * tol;
  }
  DivProjected: (this, delta: VectorEx) -> double = {
    return (this.px * delta.px + this.py * delta.py + this.pz * delta.pz)
         / (delta.px * delta.px + delta.py * delta.py + delta.pz * delta.pz);
  }
}

STriangleEx: type = {
  tag: i32 = ();
  meta: STriMeta = ();

  a: VectorEx = ();
  b: VectorEx = ();
  c: VectorEx = ();

  an: VectorEx = ();
  bn: VectorEx = ();
  cn: VectorEx = ();

  operator=: (out this, metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;
  }

  operator=: (out this, metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx, anx: VectorEx, bnx: VectorEx, cnx: VectorEx) = {
	meta = metax;
    a = ax;
	b = bx;
	c = cx;

    an = anx;
	bn = bnx;
	cn = cnx;
  }

  From: (metax: STriMeta, ax: VectorEx, bx: VectorEx, cx: VectorEx) -> STriangleEx = {
    return STriangleEx(metax, ax, bx, cx);
  }
  
  Normal: (this) -> VectorEx = {
    ab: VectorEx = this.b.Minus(this.a);
	bc: VectorEx = this.c.Minus(this.b);
    return ab.Cross(bc);
  }

  MinAltitude: (this) -> double = {
	altA: double = this.a.DistanceToLine(this.b, this.c.Minus(this.b));
	altB: double = this.b.DistanceToLine(this.c, this.a.Minus(this.c));
	altC: double = this.c.DistanceToLine(this.a, this.b.Minus(this.a));

    return min(altA, min(altB, altC));
  }

  ContainsPoint: (this, p: VectorEx) -> bool = {
    n: VectorEx = this.Normal();
    if (this.MinAltitude() < LENGTH_EPS) { // shouldn't happen; zero-area triangle
        return false;
    }
    return this.ContainsPointProjd(n.WithMagnitude(1.0), p);
  }

  ContainsPointProjd: (this, n: VectorEx, p: VectorEx) -> bool = {
    ab: VectorEx = this.b.Minus(this.a);
	bc: VectorEx = this.c.Minus(this.b);
	ca: VectorEx = this.a.Minus(this.c);

    no_ab: VectorEx = n.Cross(ab);
    if (no_ab.Dot(p) < no_ab.Dot(this.a) - LENGTH_EPS) { return false; }

    no_bc: VectorEx = n.Cross(bc);
    if (no_bc.Dot(p) < no_bc.Dot(this.b) - LENGTH_EPS) { return false; }

    no_ca: VectorEx = n.Cross(ca);
    if (no_ca.Dot(p) < no_ca.Dot(this.c) - LENGTH_EPS) { return false; }

    return true;
  }
  SignedVolume: (this) -> double = {
    return this.a.Dot(this.b.Cross(this.c)) / 6.0;
  }
  Area: (this) -> double = {
    ab: VectorEx = this.a.Minus(this.b);
    cb: VectorEx = this.c.Minus(this.b);
    return ab.Cross(cb).Magnitude() / 2.0;
  }

  IsDegenerate: (this) -> bool = {
    return this.a.OnLineSegment(this.b, this.c) ||
           this.b.OnLineSegment(this.a, this.c) ||
           this.c.OnLineSegment(this.a, this.b);
  }
  FlipNormal: (inout this) = {
    std::swap(this.a, this.b);
    std::swap(this.an, this.bn);
  }

  Transform: (this, u: VectorEx, v: VectorEx, n: VectorEx) -> STriangleEx = {
	return STriangleEx(this.meta,
	  this.a.ScaleOutOfCsys(u, v, n),
	  this.b.ScaleOutOfCsys(u, v, n),
	  this.c.ScaleOutOfCsys(u, v, n),
      this.an.ScaleOutOfCsys(u, v, n),
      this.bn.ScaleOutOfCsys(u, v, n),
      this.cn.ScaleOutOfCsys(u, v, n)
	);
  }
}
